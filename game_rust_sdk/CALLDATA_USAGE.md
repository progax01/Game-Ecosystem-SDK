# Using Contract Call Data with Game Token SDK

This document explains how to use the call data generated by the Game Token SDK to interact with Ethereum contracts.

## What is Call Data?

Call data is the encoded input data sent to an Ethereum smart contract when calling its functions. It consists of:

1. **Function Selector**: First 4 bytes, derived from the function signature
2. **Parameter Data**: Encoded parameters according to the ABI specification

The SDK generates this call data for you in the correct format, so you don't need to understand the low-level details.

## How to Use the Generated Call Data

### Option 1: Web3 Libraries

In JavaScript/TypeScript applications (frontend or Node.js), use a web3 library like ethers.js:

```javascript
import { ethers } from 'ethers';

async function sendTransaction(calldata, contractAddress) {
  // Connect to the provider (e.g., MetaMask or an RPC endpoint)
  const provider = new ethers.providers.Web3Provider(window.ethereum);
  const signer = provider.getSigner();
  
  // Create transaction object
  const tx = {
    to: contractAddress,
    data: calldata, // The calldata generated by the SDK
    gasLimit: ethers.utils.hexlify(300000), // Adjust based on function complexity
  };
  
  // Send the transaction
  const txResponse = await signer.sendTransaction(tx);
  console.log(`Transaction sent: ${txResponse.hash}`);
  
  // Wait for the transaction to be mined
  const receipt = await txResponse.wait();
  console.log(`Transaction confirmed in block ${receipt.blockNumber}`);
}
```

### Option 2: Direct Web3 Wallets (MetaMask)

For direct wallet integration (like MetaMask):

```javascript
async function sendWithMetaMask(calldata, contractAddress) {
  const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
  const account = accounts[0];
  
  const txParams = {
    from: account,
    to: contractAddress,
    data: calldata, // The calldata generated by the SDK
    gas: '0x493e0', // Hex for 300,000 gas limit
  };
  
  const txHash = await window.ethereum.request({
    method: 'eth_sendTransaction',
    params: [txParams],
  });
  
  console.log(`Transaction sent: ${txHash}`);
}
```

### Option 3: Using with Rust Web3 Libraries

In a Rust application using web3 or ethers-rs:

```rust
use ethers::{
    prelude::*,
    providers::{Http, Provider},
    signers::LocalWallet,
    types::{TransactionRequest, Bytes},
};
use std::convert::TryFrom;
use std::str::FromStr;

async fn send_transaction(
    calldata: &str,
    contract_address: &str,
    private_key: &str,
    rpc_url: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    // Connect to provider
    let provider = Provider::<Http>::try_from(rpc_url)?;
    
    // Create signer from private key
    let wallet = LocalWallet::from_str(private_key)?;
    let client = SignerMiddleware::new(provider, wallet);
    
    // Parse contract address
    let address = Address::from_str(contract_address)?;
    
    // Create transaction
    let calldata_bytes = Bytes::from_str(calldata)?;
    let tx = TransactionRequest::new()
        .to(address)
        .data(calldata_bytes)
        .gas(300_000u64);
    
    // Send the transaction
    let pending_tx = client.send_transaction(tx, None).await?;
    println!("Transaction sent: {}", pending_tx.tx_hash());
    
    // Wait for the transaction to be mined
    let receipt = pending_tx.await?;
    println!("Transaction included in block: {:?}", receipt.block_number);
    
    Ok(())
}
```

## Example Flow: Creating a Game Token

To complete the full flow of creating a game token, follow these steps:

1. **CRIDA Token Approval**:
   - Use the `creda_approve` call data with the CRIDA token contract address

2. **Lock CRIDA Tokens**:
   - After approval is confirmed, use the `lock_creda` call data with the factory contract address

3. **XP Token Approval**:
   - Use the `xp_approve` call data with the XP token contract address

4. **Create Game Token**:
   - After approval is confirmed, use the `create_token` call data with the factory contract address

You can use the `CompleteFlowCallData` struct from the SDK that contains all these call data values.

## Example Flow: Burning Game Tokens

To burn game tokens and retrieve XP:

1. **Game Token Approval**:
   - Use the `game_token_approve` call data with the game token contract address

2. **Burn Game Tokens**:
   - After approval is confirmed, use the `burn_game_token` call data with the factory contract address

You can use the `BurnFlowCallData` struct from the SDK that contains both call data values.

## Verifying Function Execution

To verify that your function call was successful:

1. **Check Transaction Receipt**:
   - Ensure the transaction was included in a block and didn't revert

2. **Check Events**:
   - The contracts emit events (logs) when functions execute successfully
   - Example events: `CredaLocked`, `GameTokenCreated`, `GameTokenBurned`

3. **Query Contract State**:
   - After function execution, you can query contract state to verify changes
   - Example: Check XP token balance after locking CREDA

## Gas Considerations

The SDK doesn't set gas limits or gas prices. When sending transactions:

1. **Set Appropriate Gas Limit**:
   - 300,000 is usually sufficient for most operations
   - Creating a game token may require higher limits (~2,000,000)

2. **Set Appropriate Gas Price/Fee**:
   - Use your wallet's recommended fee or a gas price oracle

## Security Considerations

1. **Verify Contract Addresses**:
   - Always verify you're interacting with the correct contract addresses

2. **Check Approval Amounts**:
   - When approving tokens, consider the security implications of the approval amount

3. **Transaction Confirmation**:
   - Wait for sufficient confirmations before considering a transaction final 